## Incident Response Training Exercise: Cart Service Memory Leak

This document outlines the changes made to the cart microservice to introduce a controlled failure scenario for an incident response training exercise.

### Changes

The following modifications were made to the `cart/server.js` file:

1.  **Global Array Introduction:**
    *   A new global array named `problematicGlobalArray` was declared and initialized as an empty array:
        ```javascript
        const problematicGlobalArray = [];
        ```

2.  **Data Accumulation in `/add` Endpoint:**
    *   Within the route handler for `app.get('/add/:id/:sku/:qty')`, specifically after a cart is successfully saved (`saveCart(...).then((data) => { ... })`), code has been added to populate the `problematicGlobalArray`.
    *   For every item added to a cart, an object containing `cartId`, `sku`, `qty`, a `timestamp`, and a deep copy of `productDetails` is created and pushed into this global array.
        ```javascript
        // ... inside the .then() block of saveCart
        const leakData = { 
            cartId: req.params.id, 
            sku: req.params.sku, 
            qty: qty, 
            timestamp: new Date().toISOString(),
            productDetails: JSON.parse(JSON.stringify(product))
        };
        problematicGlobalArray.push(leakData); 
        ```

### How Changes Affect Application

These changes introduce a **memory leak** into the cart microservice.

*   **Memory Exhaustion:** Each time an item is added to any user's cart, data related to that action is stored in the `problematicGlobalArray`. Since this array is global and there is no mechanism to clear or limit its size, it will grow indefinitely as users interact with the shopping cart functionality. Over time, and especially under load (as generated by `load-gen/robot-shop.py`), the Node.js process hosting the cart service will consume an increasing amount of memory.
*   **Service Degradation and Crash:** As memory usage climbs, the service will experience performance degradation due to increased garbage collection pressure. Eventually, the process will exhaust available heap memory, leading to a crash (typically with an "out of memory" error). This will render the cart service unavailable, impacting any operations that depend on it (e.g., adding items to cart, viewing cart, checkout process).
*   **Observability:** The memory leak will be observable through:
    *   Steadily increasing memory utilization metrics for the cart service.
    *   Potentially increased CPU usage due to garbage collection.
    *   Increased latency in cart operations before the crash.
    *   Error logs indicating an out-of-memory condition when the service finally fails.
*   **No Build/Static Analysis Detection:** The introduced code is syntactically valid and does not represent a pattern that static analysis tools would typically flag as an error. The issue is a runtime problem related to unbounded data accumulation in a long-lived global variable.